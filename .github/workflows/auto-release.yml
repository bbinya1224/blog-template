name: Auto Release with Gemini AI

on:
  push:
    branches:
      - main

jobs:
  create-release:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # ì „ì²´ íˆìŠ¤í† ë¦¬ ê°€ì ¸ì˜¤ê¸°

      - name: Get latest release tag
        id: get_tag
        run: |
          # ìµœì‹  ë¦´ë¦¬ì¦ˆ íƒœê·¸ ê°€ì ¸ì˜¤ê¸°
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v1.0.0")
          echo "latest_tag=$LATEST_TAG" >> $GITHUB_OUTPUT

          # ë²„ì „ ì¦ê°€ (v1.0.x -> v1.0.(x+1))
          if [[ $LATEST_TAG =~ v([0-9]+)\.([0-9]+)\.([0-9]+) ]]; then
            MAJOR="${BASH_REMATCH[1]}"
            MINOR="${BASH_REMATCH[2]}"
            PATCH="${BASH_REMATCH[3]}"
            NEW_PATCH=$((PATCH + 1))
            NEW_TAG="v${MAJOR}.${MINOR}.${NEW_PATCH}"
          else
            NEW_TAG="v1.0.1"
          fi

          echo "new_tag=$NEW_TAG" >> $GITHUB_OUTPUT
          echo "Latest tag: $LATEST_TAG"
          echo "New tag: $NEW_TAG"

      - name: Get commit messages since last release
        id: get_commits
        run: |
          LATEST_TAG="${{ steps.get_tag.outputs.latest_tag }}"

          # ìµœì‹  íƒœê·¸ ì´í›„ì˜ ì»¤ë°‹ ë©”ì‹œì§€ ê°€ì ¸ì˜¤ê¸°
          if git rev-parse "$LATEST_TAG" >/dev/null 2>&1; then
            COMMITS=$(git log $LATEST_TAG..HEAD --pretty=format:"- %s (%h)" --no-merges)
          else
            # íƒœê·¸ê°€ ì—†ìœ¼ë©´ ìµœê·¼ 10ê°œ ì»¤ë°‹
            COMMITS=$(git log -10 --pretty=format:"- %s (%h)" --no-merges)
          fi

          # ì—¬ëŸ¬ ì¤„ ì¶œë ¥ì„ ìœ„í•´ EOF ì‚¬ìš©
          echo "commits<<EOF" >> $GITHUB_OUTPUT
          echo "$COMMITS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Generate changelog with Gemini AI
        id: generate_changelog
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        run: |
          NEW_TAG="${{ steps.get_tag.outputs.new_tag }}"
          COMMITS="${{ steps.get_commits.outputs.commits }}"

          # Gemini API í”„ë¡¬í”„íŠ¸ ìƒì„±
          PROMPT="ë‹¤ìŒì€ GitHub ì €ì¥ì†Œì˜ ìµœê·¼ ì»¤ë°‹ ë©”ì‹œì§€ì…ë‹ˆë‹¤:

          $COMMITS

          ìœ„ ì»¤ë°‹ ë‚´ìš©ì„ ë¶„ì„í•˜ì—¬ ë‹¤ìŒ í˜•ì‹ìœ¼ë¡œ í•œêµ­ì–´ CHANGELOGë¥¼ ì‘ì„±í•´ì£¼ì„¸ìš”:

          ## [$NEW_TAG] - $(date +%Y.%m.%d)

          ### ğŸš€ ì£¼ìš” ë³€ê²½ì‚¬í•­
          (í•µì‹¬ ë³€ê²½ì‚¬í•­ 2-3ì¤„ ìš”ì•½)

          ### âœ¨ ìƒˆë¡œìš´ ê¸°ëŠ¥
          (ì¶”ê°€ëœ ê¸°ëŠ¥ë“¤)

          ### ğŸ› ë²„ê·¸ ìˆ˜ì •
          (ìˆ˜ì •ëœ ë²„ê·¸ë“¤)

          ### ğŸ› ï¸ ê°œì„ ì‚¬í•­
          (ê°œì„ ëœ ë¶€ë¶„ë“¤)

          ### ğŸ“¦ ë³€ê²½ëœ íŒŒì¼
          (ì£¼ìš” ë³€ê²½ íŒŒì¼ë“¤)

          í•´ë‹¹ ì„¹ì…˜ì— ë‚´ìš©ì´ ì—†ìœ¼ë©´ ìƒëµí•˜ê³ , ë§ˆí¬ë‹¤ìš´ í˜•ì‹ìœ¼ë¡œ ê¹”ë”í•˜ê²Œ ì‘ì„±í•´ì£¼ì„¸ìš”."

          # Gemini API í˜¸ì¶œ
          RESPONSE=$(curl -s -X POST \
            "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=$GEMINI_API_KEY" \
            -H "Content-Type: application/json" \
            -d "{
              \"contents\": [{
                \"parts\": [{
                  \"text\": $(echo "$PROMPT" | jq -Rs .)
                }]
              }],
              \"generationConfig\": {
                \"temperature\": 0.3,
                \"topK\": 40,
                \"topP\": 0.95,
                \"maxOutputTokens\": 2048
              }
            }")

          # Gemini ì‘ë‹µì—ì„œ í…ìŠ¤íŠ¸ ì¶”ì¶œ
          CHANGELOG=$(echo "$RESPONSE" | jq -r '.candidates[0].content.parts[0].text')

          if [ -z "$CHANGELOG" ] || [ "$CHANGELOG" = "null" ]; then
            echo "Error: Gemini API ì‘ë‹µì´ ë¹„ì–´ìˆìŠµë‹ˆë‹¤"
            echo "API Response: $RESPONSE"
            exit 1
          fi

          # ì—¬ëŸ¬ ì¤„ ì¶œë ¥ì„ ìœ„í•´ EOF ì‚¬ìš©
          echo "changelog<<EOF" >> $GITHUB_OUTPUT
          echo "$CHANGELOG" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Update CHANGELOG.md
        run: |
          CHANGELOG="${{ steps.generate_changelog.outputs.changelog }}"

          # CHANGELOG.md ë°±ì—…
          cp CHANGELOG.md CHANGELOG.md.bak

          # ìƒˆ ë‚´ìš©ì„ ì„ì‹œ íŒŒì¼ì— ì‘ì„±
          echo "# Changelog" > CHANGELOG.new.md
          echo "" >> CHANGELOG.new.md
          echo "All notable changes to this project will be documented in this file." >> CHANGELOG.new.md
          echo "" >> CHANGELOG.new.md
          echo "$CHANGELOG" >> CHANGELOG.new.md
          echo "" >> CHANGELOG.new.md
          echo "---" >> CHANGELOG.new.md
          echo "" >> CHANGELOG.new.md

          # ê¸°ì¡´ CHANGELOGì—ì„œ í—¤ë” ì´í›„ ë‚´ìš© ì¶”ê°€ (ì²« ## ë¶€í„°)
          sed -n '/^## \[/,$p' CHANGELOG.md >> CHANGELOG.new.md

          # ìƒˆ íŒŒì¼ë¡œ êµì²´
          mv CHANGELOG.new.md CHANGELOG.md

          echo "CHANGELOG.md updated successfully"

      - name: Commit and push CHANGELOG
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"

          git add CHANGELOG.md
          git commit -m "chore: update CHANGELOG for ${{ steps.get_tag.outputs.new_tag }}" || echo "No changes to commit"
          git push origin main

      - name: Create GitHub Release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          NEW_TAG="${{ steps.get_tag.outputs.new_tag }}"
          CHANGELOG="${{ steps.generate_changelog.outputs.changelog }}"

          # Release ìƒì„±
          gh release create "$NEW_TAG" \
            --title "$NEW_TAG" \
            --notes "$CHANGELOG" \
            --latest

          echo "Release $NEW_TAG created successfully"
