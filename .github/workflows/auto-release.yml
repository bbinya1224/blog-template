name: Auto Release with Gemini AI

on:
  push:
    branches:
      - main

jobs:
  create-release:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # ì „ì²´ íˆìŠ¤í† ë¦¬ ê°€ì ¸ì˜¤ê¸°

      - name: Get latest release tag
        id: get_tag
        run: |
          # ìµœì‹  ë¦´ë¦¬ì¦ˆ íƒœê·¸ ê°€ì ¸ì˜¤ê¸°
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v1.0.0")
          echo "latest_tag=$LATEST_TAG" >> $GITHUB_OUTPUT

          # ë²„ì „ ì¦ê°€ (v1.0.x -> v1.0.(x+1))
          if [[ $LATEST_TAG =~ v([0-9]+)\.([0-9]+)\.([0-9]+) ]]; then
            MAJOR="${BASH_REMATCH[1]}"
            MINOR="${BASH_REMATCH[2]}"
            PATCH="${BASH_REMATCH[3]}"
            NEW_PATCH=$((PATCH + 1))
            NEW_TAG="v${MAJOR}.${MINOR}.${NEW_PATCH}"
          else
            NEW_TAG="v1.0.1"
          fi

          echo "new_tag=$NEW_TAG" >> $GITHUB_OUTPUT
          echo "Latest tag: $LATEST_TAG"
          echo "New tag: $NEW_TAG"

      - name: Get commit messages since last release
        id: get_commits
        run: |
          LATEST_TAG="${{ steps.get_tag.outputs.latest_tag }}"

          # ìµœì‹  íƒœê·¸ ì´í›„ì˜ ì»¤ë°‹ ë©”ì‹œì§€ ê°€ì ¸ì˜¤ê¸°
          if git rev-parse "$LATEST_TAG" >/dev/null 2>&1; then
            COMMITS=$(git log $LATEST_TAG..HEAD --pretty=format:"- %s (%h)" --no-merges)
          else
            # íƒœê·¸ê°€ ì—†ìœ¼ë©´ ìµœê·¼ 10ê°œ ì»¤ë°‹
            COMMITS=$(git log -10 --pretty=format:"- %s (%h)" --no-merges)
          fi

          # ì—¬ëŸ¬ ì¤„ ì¶œë ¥ì„ ìœ„í•´ EOF ì‚¬ìš©
          echo "commits<<EOF" >> $GITHUB_OUTPUT
          echo "$COMMITS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Generate changelog with Gemini AI
        id: generate_changelog
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        run: |
          NEW_TAG="${{ steps.get_tag.outputs.new_tag }}"
          COMMITS="${{ steps.get_commits.outputs.commits }}"

          # Gemini API í”„ë¡¬í”„íŠ¸ ìƒì„±
          PROMPT="ë‹¤ìŒì€ GitHub ì €ì¥ì†Œì˜ ìµœê·¼ ì»¤ë°‹ ë©”ì‹œì§€ì…ë‹ˆë‹¤:

          $COMMITS

          ìœ„ ì»¤ë°‹ ë‚´ìš©ì„ ë¶„ì„í•˜ì—¬ ë‹¤ìŒ í˜•ì‹ìœ¼ë¡œ í•œêµ­ì–´ CHANGELOGë¥¼ ì‘ì„±í•´ì£¼ì„¸ìš”:

          ## [$NEW_TAG] - $(date +%Y.%m.%d)

          ### ğŸš€ ì£¼ìš” ë³€ê²½ì‚¬í•­
          (í•µì‹¬ ë³€ê²½ì‚¬í•­ 2-3ì¤„ ìš”ì•½)

          ### âœ¨ ìƒˆë¡œìš´ ê¸°ëŠ¥
          (ì¶”ê°€ëœ ê¸°ëŠ¥ë“¤)

          ### ğŸ› ë²„ê·¸ ìˆ˜ì •
          (ìˆ˜ì •ëœ ë²„ê·¸ë“¤)

          ### ğŸ› ï¸ ê°œì„ ì‚¬í•­
          (ê°œì„ ëœ ë¶€ë¶„ë“¤)

          ### ğŸ“¦ ë³€ê²½ëœ íŒŒì¼
          (ì£¼ìš” ë³€ê²½ íŒŒì¼ë“¤)

          í•´ë‹¹ ì„¹ì…˜ì— ë‚´ìš©ì´ ì—†ìœ¼ë©´ ìƒëµí•˜ê³ , ë§ˆí¬ë‹¤ìš´ í˜•ì‹ìœ¼ë¡œ ê¹”ë”í•˜ê²Œ ì‘ì„±í•´ì£¼ì„¸ìš”."

          # Fallback CHANGELOG í•¨ìˆ˜ (AI ì‹¤íŒ¨ ì‹œ ì‚¬ìš©)
          generate_fallback_changelog() {
            echo "## [$NEW_TAG] - $(date +%Y.%m.%d)"
            echo ""
            echo "### ğŸ“ ë³€ê²½ì‚¬í•­"
            echo ""
            echo "$COMMITS"
          }

          # ì¬ì‹œë„ ë¡œì§ (ìµœëŒ€ 3íšŒ, exponential backoff)
          MAX_RETRIES=3
          RETRY_COUNT=0
          SUCCESS=false

          while [ $RETRY_COUNT -lt $MAX_RETRIES ] && [ "$SUCCESS" = "false" ]; do
            echo "Gemini API í˜¸ì¶œ ì‹œë„ $((RETRY_COUNT + 1))/$MAX_RETRIES..."

            # Gemini API í˜¸ì¶œ (ë” ì•ˆì •ì ì¸ gemini-1.5-flash ëª¨ë¸ ì‚¬ìš©)
            RESPONSE=$(curl -s -X POST \
              "https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=$GEMINI_API_KEY" \
              -H "Content-Type: application/json" \
              -d "{
                \"contents\": [{
                  \"parts\": [{
                    \"text\": $(echo "$PROMPT" | jq -Rs .)
                  }]
                }],
                \"generationConfig\": {
                  \"temperature\": 0.3,
                  \"topK\": 40,
                  \"topP\": 0.95,
                  \"maxOutputTokens\": 2048
                }
              }")

            # ì—ëŸ¬ ì²´í¬
            ERROR_CODE=$(echo "$RESPONSE" | jq -r '.error.code // empty')

            if [ -n "$ERROR_CODE" ]; then
              echo "Gemini API ì—ëŸ¬ ë°œìƒ: $ERROR_CODE"
              ERROR_MESSAGE=$(echo "$RESPONSE" | jq -r '.error.message')
              echo "ì—ëŸ¬ ë©”ì‹œì§€: $ERROR_MESSAGE"

              # 429 (Rate Limit) ë˜ëŠ” 503 (Service Unavailable) ì—ëŸ¬ëŠ” ì¬ì‹œë„
              if [ "$ERROR_CODE" = "429" ] || [ "$ERROR_CODE" = "503" ]; then
                RETRY_COUNT=$((RETRY_COUNT + 1))
                if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                  WAIT_TIME=$((2 ** RETRY_COUNT))  # Exponential backoff: 2, 4, 8ì´ˆ
                  echo "â³ ${WAIT_TIME}ì´ˆ í›„ ì¬ì‹œë„í•©ë‹ˆë‹¤..."
                  sleep $WAIT_TIME
                fi
              else
                # ë‹¤ë¥¸ ì—ëŸ¬ëŠ” ì¦‰ì‹œ fallback
                echo "âš ï¸  ë³µêµ¬ ë¶ˆê°€ëŠ¥í•œ ì—ëŸ¬. Fallback CHANGELOG ì‚¬ìš©"
                break
              fi
            else
              # ì„±ê³µ: ì‘ë‹µ íŒŒì‹±
              CHANGELOG=$(echo "$RESPONSE" | jq -r '.candidates[0].content.parts[0].text // empty')

              if [ -n "$CHANGELOG" ] && [ "$CHANGELOG" != "null" ]; then
                echo "âœ… Gemini AIë¡œ CHANGELOG ìƒì„± ì„±ê³µ"
                SUCCESS=true
              else
                echo "âš ï¸  ì‘ë‹µì€ ë°›ì•˜ìœ¼ë‚˜ ë‚´ìš©ì´ ë¹„ì–´ìˆìŒ"
                RETRY_COUNT=$((RETRY_COUNT + 1))
                if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                  sleep 2
                fi
              fi
            fi
          done

          # ìµœì¢… ì‹¤íŒ¨ ì‹œ Fallback ì‚¬ìš©
          if [ "$SUCCESS" = "false" ]; then
            echo "âŒ Gemini API í˜¸ì¶œ ì‹¤íŒ¨. Fallback CHANGELOG ìƒì„± ì¤‘..."
            CHANGELOG=$(generate_fallback_changelog)
          fi

          # ì—¬ëŸ¬ ì¤„ ì¶œë ¥ì„ ìœ„í•´ EOF ì‚¬ìš©
          echo "changelog<<EOF" >> $GITHUB_OUTPUT
          echo "$CHANGELOG" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Update CHANGELOG.md
        run: |
          CHANGELOG="${{ steps.generate_changelog.outputs.changelog }}"

          # CHANGELOG.md ë°±ì—…
          cp CHANGELOG.md CHANGELOG.md.bak

          # ìƒˆ ë‚´ìš©ì„ ì„ì‹œ íŒŒì¼ì— ì‘ì„±
          echo "# Changelog" > CHANGELOG.new.md
          echo "" >> CHANGELOG.new.md
          echo "All notable changes to this project will be documented in this file." >> CHANGELOG.new.md
          echo "" >> CHANGELOG.new.md
          echo "$CHANGELOG" >> CHANGELOG.new.md
          echo "" >> CHANGELOG.new.md
          echo "---" >> CHANGELOG.new.md
          echo "" >> CHANGELOG.new.md

          # ê¸°ì¡´ CHANGELOGì—ì„œ í—¤ë” ì´í›„ ë‚´ìš© ì¶”ê°€ (ì²« ## ë¶€í„°)
          sed -n '/^## \[/,$p' CHANGELOG.md >> CHANGELOG.new.md

          # ìƒˆ íŒŒì¼ë¡œ êµì²´
          mv CHANGELOG.new.md CHANGELOG.md

          echo "CHANGELOG.md updated successfully"

      - name: Commit and push CHANGELOG
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"

          git add CHANGELOG.md
          git commit -m "chore: update CHANGELOG for ${{ steps.get_tag.outputs.new_tag }}" || echo "No changes to commit"
          git push origin main

      - name: Create GitHub Release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          NEW_TAG="${{ steps.get_tag.outputs.new_tag }}"
          CHANGELOG="${{ steps.generate_changelog.outputs.changelog }}"

          # Release ìƒì„±
          gh release create "$NEW_TAG" \
            --title "$NEW_TAG" \
            --notes "$CHANGELOG" \
            --latest

          echo "Release $NEW_TAG created successfully"
